/*
Alldebrid API

Welcome to the Alldebrid API! You can use this API to access various Alldebrid services from custom applications or scripts.

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
)

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiV41MagnetStatusGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
	id         *string
	status     *string
	session    *string
	counter    *string
}

// Your software user-agent.
func (r ApiV41MagnetStatusGetRequest) Agent(agent string) ApiV41MagnetStatusGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV41MagnetStatusGetRequest) Apikey(apikey string) ApiV41MagnetStatusGetRequest {
	r.apikey = &apikey
	return r
}

// Magnet ID.
func (r ApiV41MagnetStatusGetRequest) Id(id string) ApiV41MagnetStatusGetRequest {
	r.id = &id
	return r
}

// Magnets status filter. Either active, ready, expired or error
func (r ApiV41MagnetStatusGetRequest) Status(status string) ApiV41MagnetStatusGetRequest {
	r.status = &status
	return r
}

// Session ID for Live mode (see Live Mode).
func (r ApiV41MagnetStatusGetRequest) Session(session string) ApiV41MagnetStatusGetRequest {
	r.session = &session
	return r
}

// Counter for Live mode (see Live Mode).
func (r ApiV41MagnetStatusGetRequest) Counter(counter string) ApiV41MagnetStatusGetRequest {
	r.counter = &counter
	return r
}

func (r ApiV41MagnetStatusGetRequest) Execute() (*V41MagnetStatusGet200Response, *http.Response, error) {
	return r.ApiService.V41MagnetStatusGetExecute(r)
}

/*
V41MagnetStatusGet Get the status of current magnets, or only one if you specify a magnet ID.

Get the status of current magnets, or only one if you specify a magnet ID.

- Live Mode:

The Live Mode allows to only get the new data of the status of current magnets. It is designed to make a "live" panel or monitoring system more performant when consuming the magnet/status endpoint very frequently.

It requires a session ID and a counter, and using cache on the API side only the differences between the last state and the current state are sent, greatly reducing the amount of data returned by the API on each call.

The client using this mode must keep the current state of the magnets status locally between each call in order to apply the new data on the last state to get the whole current state.

A fixed session ID (integer) must be randomly set, and a counter starting at 0 will be used. On the first call (id=123, counter=0) with a new session ID, all the current data will be sent back, with the fullsync property set to true to make it clear, and the next counter to use. On the next call the updated counter is used (id=123, counter=1), and only the differences with the previous state will be send back.

If the magnets property returned is empty, then no change happened since the last call. If some changes happened, the magnets array will have some magnet objects (see Status) with its id and the properties changed, like this:

`{ "id": 123456, "downloaded": 258879224, "downloadSpeed": 20587738 }`

You can them apply those diff to the last state you kept to get the current magnets status state.

If you send a counter that is not in sync with the last call response (like sending the same counter twice in a row), then the endpoint will consider your counter invalid and will return a full fullsync reponse with a reseted counter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV41MagnetStatusGetRequest
*/
func (a *DefaultAPIService) V41MagnetStatusGet(ctx context.Context) ApiV41MagnetStatusGetRequest {
	return ApiV41MagnetStatusGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V41MagnetStatusGet200Response
func (a *DefaultAPIService) V41MagnetStatusGetExecute(r ApiV41MagnetStatusGetRequest) (*V41MagnetStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V41MagnetStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V41MagnetStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4.1/magnet/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.session != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "session", r.session, "form", "")
	}
	if r.counter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counter", r.counter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4HostsDomainsGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
}

// Your software user-agent.
func (r ApiV4HostsDomainsGetRequest) Agent(agent string) ApiV4HostsDomainsGetRequest {
	r.agent = &agent
	return r
}

func (r ApiV4HostsDomainsGetRequest) Execute() (*V4HostsDomainsGet200Response, *http.Response, error) {
	return r.ApiService.V4HostsDomainsGetExecute(r)
}

/*
V4HostsDomainsGet Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array.

Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array. This will also include any alternative domain the hosts or redirectors have. Please use regexps availables in /hosts or /user/hosts endpoints to validate supported links.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4HostsDomainsGetRequest
*/
func (a *DefaultAPIService) V4HostsDomainsGet(ctx context.Context) ApiV4HostsDomainsGetRequest {
	return ApiV4HostsDomainsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4HostsDomainsGet200Response
func (a *DefaultAPIService) V4HostsDomainsGetExecute(r ApiV4HostsDomainsGetRequest) (*V4HostsDomainsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4HostsDomainsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4HostsDomainsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/hosts/domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4HostsGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	hostOnly   *string
}

// Your software user-agent.
func (r ApiV4HostsGetRequest) Agent(agent string) ApiV4HostsGetRequest {
	r.agent = &agent
	return r
}

// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiV4HostsGetRequest) HostOnly(hostOnly string) ApiV4HostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiV4HostsGetRequest) Execute() (*V4HostsGet200Response, *http.Response, error) {
	return r.ApiService.V4HostsGetExecute(r)
}

/*
V4HostsGet Use this endpoint to retrieve informations about what hosts we support.

Use this endpoint to retrieve informations about what hosts we support and all related informations about it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4HostsGetRequest
*/
func (a *DefaultAPIService) V4HostsGet(ctx context.Context) ApiV4HostsGetRequest {
	return ApiV4HostsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4HostsGet200Response
func (a *DefaultAPIService) V4HostsGetExecute(r ApiV4HostsGetRequest) (*V4HostsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4HostsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4HostsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.hostOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostOnly", r.hostOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4HostsPriorityGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
}

// Your software user-agent.
func (r ApiV4HostsPriorityGetRequest) Agent(agent string) ApiV4HostsPriorityGetRequest {
	r.agent = &agent
	return r
}

func (r ApiV4HostsPriorityGetRequest) Execute() (*V4HostsPriorityGet200Response, *http.Response, error) {
	return r.ApiService.V4HostsPriorityGetExecute(r)
}

/*
V4HostsPriorityGet Not all hosts are created equal, so some hosts are more limited than other.

Use this endpoint to retrieve an ordered list of main domain of hosts, from more open to more restricted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4HostsPriorityGetRequest
*/
func (a *DefaultAPIService) V4HostsPriorityGet(ctx context.Context) ApiV4HostsPriorityGetRequest {
	return ApiV4HostsPriorityGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4HostsPriorityGet200Response
func (a *DefaultAPIService) V4HostsPriorityGetExecute(r ApiV4HostsPriorityGetRequest) (*V4HostsPriorityGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4HostsPriorityGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4HostsPriorityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/hosts/priority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4LinkDelayedGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	id         *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4LinkDelayedGetRequest) Agent(agent string) ApiV4LinkDelayedGetRequest {
	r.agent = &agent
	return r
}

// Delayed ID received in /link/unlock.
func (r ApiV4LinkDelayedGetRequest) Id(id string) ApiV4LinkDelayedGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4LinkDelayedGetRequest) Apikey(apikey string) ApiV4LinkDelayedGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4LinkDelayedGetRequest) Execute() (*V4LinkDelayedGet200Response, *http.Response, error) {
	return r.ApiService.V4LinkDelayedGetExecute(r)
}

/*
V4LinkDelayedGet This endpoint give the status of a delayed link.

This endpoint give the status of a delayed link. Some links need time to generate, this endpoint send the status of such delayed links. You should pool every 5 seconds or more the link/delayed endpoint until given the download link.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4LinkDelayedGetRequest
*/
func (a *DefaultAPIService) V4LinkDelayedGet(ctx context.Context) ApiV4LinkDelayedGetRequest {
	return ApiV4LinkDelayedGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4LinkDelayedGet200Response
func (a *DefaultAPIService) V4LinkDelayedGetExecute(r ApiV4LinkDelayedGetRequest) (*V4LinkDelayedGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4LinkDelayedGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4LinkDelayedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/link/delayed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4LinkInfosGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	link       *[]string
	apikey     *string
	password   *string
}

// Your software user-agent.
func (r ApiV4LinkInfosGetRequest) Agent(agent string) ApiV4LinkInfosGetRequest {
	r.agent = &agent
	return r
}

// The link or array of links you request informations about.
func (r ApiV4LinkInfosGetRequest) Link(link []string) ApiV4LinkInfosGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4LinkInfosGetRequest) Apikey(apikey string) ApiV4LinkInfosGetRequest {
	r.apikey = &apikey
	return r
}

// Link password (supported on uptobox / 1fichier).
func (r ApiV4LinkInfosGetRequest) Password(password string) ApiV4LinkInfosGetRequest {
	r.password = &password
	return r
}

func (r ApiV4LinkInfosGetRequest) Execute() (*V4LinkInfosGet200Response, *http.Response, error) {
	return r.ApiService.V4LinkInfosGetExecute(r)
}

/*
V4LinkInfosGet Use this endpoint to retrieve informations about a link.

Use this endpoint to retrieve informations about a link. If it is in our systems, you'll have the filename and size (if available). If the host is not supported or the link is down, an error will be returned for that link. This endpoint only support host links, not redirectors links. Use the /v4/link/redirector endpoint for this.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4LinkInfosGetRequest
*/
func (a *DefaultAPIService) V4LinkInfosGet(ctx context.Context) ApiV4LinkInfosGetRequest {
	return ApiV4LinkInfosGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4LinkInfosGet200Response
func (a *DefaultAPIService) V4LinkInfosGetExecute(r ApiV4LinkInfosGetRequest) (*V4LinkInfosGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4LinkInfosGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4LinkInfosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/link/infos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4LinkRedirectorGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	link       *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4LinkRedirectorGetRequest) Agent(agent string) ApiV4LinkRedirectorGetRequest {
	r.agent = &agent
	return r
}

// The redirector or protector link to extract links.
func (r ApiV4LinkRedirectorGetRequest) Link(link string) ApiV4LinkRedirectorGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4LinkRedirectorGetRequest) Apikey(apikey string) ApiV4LinkRedirectorGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4LinkRedirectorGetRequest) Execute() (*V4LinkRedirectorGet200Response, *http.Response, error) {
	return r.ApiService.V4LinkRedirectorGetExecute(r)
}

/*
V4LinkRedirectorGet Use this endpoint to retrieve links protected by a redirector or link protector.

Use this endpoint to retrieve links protected by a redirector or link protector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4LinkRedirectorGetRequest
*/
func (a *DefaultAPIService) V4LinkRedirectorGet(ctx context.Context) ApiV4LinkRedirectorGetRequest {
	return ApiV4LinkRedirectorGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4LinkRedirectorGet200Response
func (a *DefaultAPIService) V4LinkRedirectorGetExecute(r ApiV4LinkRedirectorGetRequest) (*V4LinkRedirectorGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4LinkRedirectorGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4LinkRedirectorGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/link/redirector"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4LinkStreamingGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	id         *string
	stream     *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4LinkStreamingGetRequest) Agent(agent string) ApiV4LinkStreamingGetRequest {
	r.agent = &agent
	return r
}

// The link ID you received from the /link/unlock call.
func (r ApiV4LinkStreamingGetRequest) Id(id string) ApiV4LinkStreamingGetRequest {
	r.id = &id
	return r
}

// The stream ID you choosed from the stream qualities list returned by /link/unlock.
func (r ApiV4LinkStreamingGetRequest) Stream(stream string) ApiV4LinkStreamingGetRequest {
	r.stream = &stream
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4LinkStreamingGetRequest) Apikey(apikey string) ApiV4LinkStreamingGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4LinkStreamingGetRequest) Execute() (*V4LinkStreamingGet200Response, *http.Response, error) {
	return r.ApiService.V4LinkStreamingGetExecute(r)
}

/*
V4LinkStreamingGet The unlocking flow for streaming link is a bit more complex.

First hit the usual link/unlock endpoint. Two cases: Stream link has only one quality: downloading link is available immediately. OR Stream links has multiple qualities: you must select the desired quality to obtain a download link or delayed id by using the /v4/link/streaming endpoint. Depending of the stream website, you'll either get a download link, or a delayed id (see Delayed link section for delayed links).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4LinkStreamingGetRequest
*/
func (a *DefaultAPIService) V4LinkStreamingGet(ctx context.Context) ApiV4LinkStreamingGetRequest {
	return ApiV4LinkStreamingGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4LinkStreamingGet200Response
func (a *DefaultAPIService) V4LinkStreamingGetExecute(r ApiV4LinkStreamingGetRequest) (*V4LinkStreamingGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4LinkStreamingGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4LinkStreamingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/link/streaming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.stream == nil {
		return localVarReturnValue, nil, reportError("stream is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "stream", r.stream, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4LinkUnlockGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	link       *string
	apikey     *string
	password   *string
}

// Your software user-agent.
func (r ApiV4LinkUnlockGetRequest) Agent(agent string) ApiV4LinkUnlockGetRequest {
	r.agent = &agent
	return r
}

// The redirector or protector link to extract links.
func (r ApiV4LinkUnlockGetRequest) Link(link string) ApiV4LinkUnlockGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4LinkUnlockGetRequest) Apikey(apikey string) ApiV4LinkUnlockGetRequest {
	r.apikey = &apikey
	return r
}

// Link password (supported on uptobox / 1fichier).
func (r ApiV4LinkUnlockGetRequest) Password(password string) ApiV4LinkUnlockGetRequest {
	r.password = &password
	return r
}

func (r ApiV4LinkUnlockGetRequest) Execute() (*V4LinkUnlockGet200Response, *http.Response, error) {
	return r.ApiService.V4LinkUnlockGetExecute(r)
}

/*
V4LinkUnlockGet This endpoint unlocks a given link.

This endpoint can return a delayed ID. In that case, you must follow the delayed link flow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4LinkUnlockGetRequest
*/
func (a *DefaultAPIService) V4LinkUnlockGet(ctx context.Context) ApiV4LinkUnlockGetRequest {
	return ApiV4LinkUnlockGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4LinkUnlockGet200Response
func (a *DefaultAPIService) V4LinkUnlockGetExecute(r ApiV4LinkUnlockGetRequest) (*V4LinkUnlockGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4LinkUnlockGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4LinkUnlockGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/link/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "form", "")
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4MagnetDeleteGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	id         *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4MagnetDeleteGetRequest) Agent(agent string) ApiV4MagnetDeleteGetRequest {
	r.agent = &agent
	return r
}

// Magnet ID.
func (r ApiV4MagnetDeleteGetRequest) Id(id string) ApiV4MagnetDeleteGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4MagnetDeleteGetRequest) Apikey(apikey string) ApiV4MagnetDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4MagnetDeleteGetRequest) Execute() (*V4MagnetDeleteGet200Response, *http.Response, error) {
	return r.ApiService.V4MagnetDeleteGetExecute(r)
}

/*
V4MagnetDeleteGet Delete a magnet.

Delete a magnet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4MagnetDeleteGetRequest
*/
func (a *DefaultAPIService) V4MagnetDeleteGet(ctx context.Context) ApiV4MagnetDeleteGetRequest {
	return ApiV4MagnetDeleteGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4MagnetDeleteGet200Response
func (a *DefaultAPIService) V4MagnetDeleteGetExecute(r ApiV4MagnetDeleteGetRequest) (*V4MagnetDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4MagnetDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4MagnetDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/magnet/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4MagnetFilesGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
	id         *string
	status     *string
	session    *string
	counter    *string
}

// Your software user-agent.
func (r ApiV4MagnetFilesGetRequest) Agent(agent string) ApiV4MagnetFilesGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4MagnetFilesGetRequest) Apikey(apikey string) ApiV4MagnetFilesGetRequest {
	r.apikey = &apikey
	return r
}

// Magnet ID.
func (r ApiV4MagnetFilesGetRequest) Id(id string) ApiV4MagnetFilesGetRequest {
	r.id = &id
	return r
}

// Magnets status filter. Either active, ready, expired or error
func (r ApiV4MagnetFilesGetRequest) Status(status string) ApiV4MagnetFilesGetRequest {
	r.status = &status
	return r
}

// Session ID for Live mode (see Live Mode).
func (r ApiV4MagnetFilesGetRequest) Session(session string) ApiV4MagnetFilesGetRequest {
	r.session = &session
	return r
}

// Counter for Live mode (see Live Mode).
func (r ApiV4MagnetFilesGetRequest) Counter(counter string) ApiV4MagnetFilesGetRequest {
	r.counter = &counter
	return r
}

func (r ApiV4MagnetFilesGetRequest) Execute() (*V41MagnetStatusGet200Response, *http.Response, error) {
	return r.ApiService.V4MagnetFilesGetExecute(r)
}

/*
V4MagnetFilesGet Get Files and Links

Returns the files and links of a magnet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4MagnetFilesGetRequest
*/
func (a *DefaultAPIService) V4MagnetFilesGet(ctx context.Context) ApiV4MagnetFilesGetRequest {
	return ApiV4MagnetFilesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V41MagnetStatusGet200Response
func (a *DefaultAPIService) V4MagnetFilesGetExecute(r ApiV4MagnetFilesGetRequest) (*V41MagnetStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V41MagnetStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4MagnetFilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/magnet/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.session != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "session", r.session, "form", "")
	}
	if r.counter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counter", r.counter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4MagnetRestartGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	id         *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4MagnetRestartGetRequest) Agent(agent string) ApiV4MagnetRestartGetRequest {
	r.agent = &agent
	return r
}

// Magnet ID
func (r ApiV4MagnetRestartGetRequest) Id(id string) ApiV4MagnetRestartGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4MagnetRestartGetRequest) Apikey(apikey string) ApiV4MagnetRestartGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4MagnetRestartGetRequest) Execute() (*V4MagnetRestartGet200Response, *http.Response, error) {
	return r.ApiService.V4MagnetRestartGetExecute(r)
}

/*
V4MagnetRestartGet Restart a failed magnet, or multiple failed magnets at once.

Restart a failed magnet, or multiple failed magnets at once.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4MagnetRestartGetRequest
*/
func (a *DefaultAPIService) V4MagnetRestartGet(ctx context.Context) ApiV4MagnetRestartGetRequest {
	return ApiV4MagnetRestartGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4MagnetRestartGet200Response
func (a *DefaultAPIService) V4MagnetRestartGetExecute(r ApiV4MagnetRestartGetRequest) (*V4MagnetRestartGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4MagnetRestartGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4MagnetRestartGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/magnet/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4MagnetUploadFilePostRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
	files      *os.File
}

// Your software user-agent.
func (r ApiV4MagnetUploadFilePostRequest) Agent(agent string) ApiV4MagnetUploadFilePostRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4MagnetUploadFilePostRequest) Apikey(apikey string) ApiV4MagnetUploadFilePostRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4MagnetUploadFilePostRequest) Files(files *os.File) ApiV4MagnetUploadFilePostRequest {
	r.files = files
	return r
}

func (r ApiV4MagnetUploadFilePostRequest) Execute() (*V4MagnetUploadFilePost200Response, *http.Response, error) {
	return r.ApiService.V4MagnetUploadFilePostExecute(r)
}

/*
V4MagnetUploadFilePost Upload torrent files.

Upload torrent files.<br /> This endpoint should be POSTed on.<br /> It expects a multipart formdata file upload.<br />

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4MagnetUploadFilePostRequest
*/
func (a *DefaultAPIService) V4MagnetUploadFilePost(ctx context.Context) ApiV4MagnetUploadFilePostRequest {
	return ApiV4MagnetUploadFilePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4MagnetUploadFilePost200Response
func (a *DefaultAPIService) V4MagnetUploadFilePostExecute(r ApiV4MagnetUploadFilePostRequest) (*V4MagnetUploadFilePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4MagnetUploadFilePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4MagnetUploadFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/magnet/upload/file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var filesLocalVarFormFileName string
	var filesLocalVarFileName string
	var filesLocalVarFileBytes []byte

	filesLocalVarFormFileName = "files[]"
	filesLocalVarFile := r.files

	if filesLocalVarFile != nil {
		fbs, _ := io.ReadAll(filesLocalVarFile)

		filesLocalVarFileBytes = fbs
		filesLocalVarFileName = filesLocalVarFile.Name()
		filesLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filesLocalVarFileBytes, fileName: filesLocalVarFileName, formFileName: filesLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4MagnetUploadGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	magnets    *[]string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4MagnetUploadGetRequest) Agent(agent string) ApiV4MagnetUploadGetRequest {
	r.agent = &agent
	return r
}

// Magnet(s) URI or hash. Must send magnet either in GET param or in POST data.
func (r ApiV4MagnetUploadGetRequest) Magnets(magnets []string) ApiV4MagnetUploadGetRequest {
	r.magnets = &magnets
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4MagnetUploadGetRequest) Apikey(apikey string) ApiV4MagnetUploadGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4MagnetUploadGetRequest) Execute() (*V4MagnetUploadGet200Response, *http.Response, error) {
	return r.ApiService.V4MagnetUploadGetExecute(r)
}

/*
V4MagnetUploadGet Upload a magnet with its URI or hash.

Upload a magnet with its URI or hash. You can either send the magnets in GET parameters, or in POST.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4MagnetUploadGetRequest
*/
func (a *DefaultAPIService) V4MagnetUploadGet(ctx context.Context) ApiV4MagnetUploadGetRequest {
	return ApiV4MagnetUploadGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4MagnetUploadGet200Response
func (a *DefaultAPIService) V4MagnetUploadGetExecute(r ApiV4MagnetUploadGetRequest) (*V4MagnetUploadGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4MagnetUploadGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4MagnetUploadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/magnet/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.magnets == nil {
		return localVarReturnValue, nil, reportError("magnets is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	{
		t := *r.magnets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserGetRequest) Agent(agent string) ApiV4UserGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserGetRequest) Apikey(apikey string) ApiV4UserGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserGetRequest) Execute() (*V4UserGet200Response, *http.Response, error) {
	return r.ApiService.V4UserGetExecute(r)
}

/*
V4UserGet Use this endpoint to get user informations.

Use this endpoint to get user informations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserGetRequest
*/
func (a *DefaultAPIService) V4UserGet(ctx context.Context) ApiV4UserGetRequest {
	return ApiV4UserGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserGet200Response
func (a *DefaultAPIService) V4UserGetExecute(r ApiV4UserGetRequest) (*V4UserGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserHistoryDeleteGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserHistoryDeleteGetRequest) Agent(agent string) ApiV4UserHistoryDeleteGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserHistoryDeleteGetRequest) Apikey(apikey string) ApiV4UserHistoryDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserHistoryDeleteGetRequest) Execute() (*V4UserHistoryDeleteGet200Response, *http.Response, error) {
	return r.ApiService.V4UserHistoryDeleteGetExecute(r)
}

/*
V4UserHistoryDeleteGet Use this endpoint to delete all links currently in your recent links history.

Use this endpoint to delete all links currently in your recent links history. Links older than 3 days are automatically deleted from the recent history.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserHistoryDeleteGetRequest
*/
func (a *DefaultAPIService) V4UserHistoryDeleteGet(ctx context.Context) ApiV4UserHistoryDeleteGetRequest {
	return ApiV4UserHistoryDeleteGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserHistoryDeleteGet200Response
func (a *DefaultAPIService) V4UserHistoryDeleteGetExecute(r ApiV4UserHistoryDeleteGetRequest) (*V4UserHistoryDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserHistoryDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserHistoryDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/history/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserHistoryGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserHistoryGetRequest) Agent(agent string) ApiV4UserHistoryGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserHistoryGetRequest) Apikey(apikey string) ApiV4UserHistoryGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserHistoryGetRequest) Execute() (*V4UserLinksGet200Response, *http.Response, error) {
	return r.ApiService.V4UserHistoryGetExecute(r)
}

/*
V4UserHistoryGet Use this endpoint to get recent links.

Use this endpoint to get recent links. Recent link logging being disabled by default, this will return nothing until history logging has been activated in your account settings. Links older than 3 days are automatically deleted from the recent history. To keep links in your account, use the Saved links.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserHistoryGetRequest
*/
func (a *DefaultAPIService) V4UserHistoryGet(ctx context.Context) ApiV4UserHistoryGetRequest {
	return ApiV4UserHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserLinksGet200Response
func (a *DefaultAPIService) V4UserHistoryGetExecute(r ApiV4UserHistoryGetRequest) (*V4UserLinksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserLinksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserHostsGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
	hostOnly   *string
}

// Your software user-agent.
func (r ApiV4UserHostsGetRequest) Agent(agent string) ApiV4UserHostsGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserHostsGetRequest) Apikey(apikey string) ApiV4UserHostsGetRequest {
	r.apikey = &apikey
	return r
}

// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiV4UserHostsGetRequest) HostOnly(hostOnly string) ApiV4UserHostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiV4UserHostsGetRequest) Execute() (*V4HostsGet200Response, *http.Response, error) {
	return r.ApiService.V4UserHostsGetExecute(r)
}

/*
V4UserHostsGet This endpoint retrieves a complete list of all available hosts for this user.

This endpoint retrieves a complete list of all available hosts for this user. Depending of the account subscription status (free user, trial mode, premium user), the list and limitations will vary. The limits and quota are updated in real time. Use this page to have an up-to-date list of service the user can use on Alldebrid. Quotas will reset every day for premium users.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserHostsGetRequest
*/
func (a *DefaultAPIService) V4UserHostsGet(ctx context.Context) ApiV4UserHostsGetRequest {
	return ApiV4UserHostsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4HostsGet200Response
func (a *DefaultAPIService) V4UserHostsGetExecute(r ApiV4UserHostsGetRequest) (*V4HostsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4HostsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserHostsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.hostOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostOnly", r.hostOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserLinksDeleteGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
	link       *string
	link2      *[]string
}

// Your software user-agent.
func (r ApiV4UserLinksDeleteGetRequest) Agent(agent string) ApiV4UserLinksDeleteGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserLinksDeleteGetRequest) Apikey(apikey string) ApiV4UserLinksDeleteGetRequest {
	r.apikey = &apikey
	return r
}

// Link to delete.
func (r ApiV4UserLinksDeleteGetRequest) Link(link string) ApiV4UserLinksDeleteGetRequest {
	r.link = &link
	return r
}

// Links to delete.
func (r ApiV4UserLinksDeleteGetRequest) Link2(link2 []string) ApiV4UserLinksDeleteGetRequest {
	r.link2 = &link2
	return r
}

func (r ApiV4UserLinksDeleteGetRequest) Execute() (*V4UserLinksDeleteGet200Response, *http.Response, error) {
	return r.ApiService.V4UserLinksDeleteGetExecute(r)
}

/*
V4UserLinksDeleteGet Delete a saved link.

Delete a saved link.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserLinksDeleteGetRequest
*/
func (a *DefaultAPIService) V4UserLinksDeleteGet(ctx context.Context) ApiV4UserLinksDeleteGetRequest {
	return ApiV4UserLinksDeleteGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserLinksDeleteGet200Response
func (a *DefaultAPIService) V4UserLinksDeleteGetExecute(r ApiV4UserLinksDeleteGetRequest) (*V4UserLinksDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserLinksDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserLinksDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/links/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	if r.link != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "form", "")
	}
	if r.link2 != nil {
		t := *r.link2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserLinksGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserLinksGetRequest) Agent(agent string) ApiV4UserLinksGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserLinksGetRequest) Apikey(apikey string) ApiV4UserLinksGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserLinksGetRequest) Execute() (*V4UserLinksGet200Response, *http.Response, error) {
	return r.ApiService.V4UserLinksGetExecute(r)
}

/*
V4UserLinksGet Use this endpoint to get links the user saved for later use.

Use this endpoint to get links the user saved for later use.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserLinksGetRequest
*/
func (a *DefaultAPIService) V4UserLinksGet(ctx context.Context) ApiV4UserLinksGetRequest {
	return ApiV4UserLinksGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserLinksGet200Response
func (a *DefaultAPIService) V4UserLinksGetExecute(r ApiV4UserLinksGetRequest) (*V4UserLinksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserLinksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserLinksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserLinksSaveGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	link       *[]string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserLinksSaveGetRequest) Agent(agent string) ApiV4UserLinksSaveGetRequest {
	r.agent = &agent
	return r
}

// Links to save.
func (r ApiV4UserLinksSaveGetRequest) Link(link []string) ApiV4UserLinksSaveGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserLinksSaveGetRequest) Apikey(apikey string) ApiV4UserLinksSaveGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserLinksSaveGetRequest) Execute() (*V4UserLinksSaveGet200Response, *http.Response, error) {
	return r.ApiService.V4UserLinksSaveGetExecute(r)
}

/*
V4UserLinksSaveGet Save a link.

Save a link.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserLinksSaveGetRequest
*/
func (a *DefaultAPIService) V4UserLinksSaveGet(ctx context.Context) ApiV4UserLinksSaveGetRequest {
	return ApiV4UserLinksSaveGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserLinksSaveGet200Response
func (a *DefaultAPIService) V4UserLinksSaveGetExecute(r ApiV4UserLinksSaveGetRequest) (*V4UserLinksSaveGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserLinksSaveGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserLinksSaveGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/links/save"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV4UserNotificationClearGetRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	agent      *string
	code       *string
	apikey     *string
}

// Your software user-agent.
func (r ApiV4UserNotificationClearGetRequest) Agent(agent string) ApiV4UserNotificationClearGetRequest {
	r.agent = &agent
	return r
}

// Notification code to clear
func (r ApiV4UserNotificationClearGetRequest) Code(code string) ApiV4UserNotificationClearGetRequest {
	r.code = &code
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiV4UserNotificationClearGetRequest) Apikey(apikey string) ApiV4UserNotificationClearGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiV4UserNotificationClearGetRequest) Execute() (*V4UserNotificationClearGet200Response, *http.Response, error) {
	return r.ApiService.V4UserNotificationClearGetExecute(r)
}

/*
V4UserNotificationClearGet This endpoint clears a user notification with its code.

This endpoint clears a user notification with its code. Current notifications codes can be retreive from the /user endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV4UserNotificationClearGetRequest
*/
func (a *DefaultAPIService) V4UserNotificationClearGet(ctx context.Context) ApiV4UserNotificationClearGetRequest {
	return ApiV4UserNotificationClearGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V4UserNotificationClearGet200Response
func (a *DefaultAPIService) V4UserNotificationClearGetExecute(r ApiV4UserNotificationClearGetRequest) (*V4UserNotificationClearGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V4UserNotificationClearGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V4UserNotificationClearGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/user/notification/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
